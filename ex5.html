<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Exerc√≠cio 5</title>
    <script src='js/three.min.js'></script>
    <!-- include jsartookit -->
    <script src="jsartoolkit5/artoolkit.min.js"></script>
    <script src="jsartoolkit5/artoolkit.api.js"></script>
    <!-- include threex.artoolkit -->
    <script src="threex/threex-artoolkitsource.js"></script>
    <script src="threex/threex-artoolkitcontext.js"></script>
    <script src="threex/threex-arbasecontrols.js"></script>
    <script src="threex/threex-armarkercontrols.js"></script>
</head>
<body>
<script>
    var scene, camera, renderer, clock, deltaTime, totalTime, sceneGroup;
    var arToolkitSource, arToolkitContext;
    var markerRootA, markerRootB;
    var ballMesh, mesh1;


    var A = new THREE.Vector3();
    var B = new THREE.Vector3();
    var dir = new THREE.Vector3();
    const scenepos = new THREE.Vector3();


    var it = 0;

    let markerControls1, markerControls2;
    initialize();
    animate();
    function initialize()
    {
        scene = new THREE.Scene();

        camera = new THREE.Camera();
        scene.add(camera);
        renderer = new THREE.WebGLRenderer({
            antialias : true,
            alpha: true
        });
        renderer.setClearColor(new THREE.Color('lightgrey'), 0)
        renderer.setSize( 640, 480 );
        renderer.domElement.style.position = 'absolute'
        renderer.domElement.style.top = '0px'
        renderer.domElement.style.left = '0px'
        document.body.appendChild( renderer.domElement );
        clock = new THREE.Clock();
        deltaTime = 0;
        totalTime = 0;

        ////////////////////////////////////////////////////////////
        // setup arToolkitSource
        ////////////////////////////////////////////////////////////
        arToolkitSource = new THREEx.ArToolkitSource({
            sourceType : 'webcam',
        });
        function onResize()
        {
            arToolkitSource.onResize()
            arToolkitSource.copySizeTo(renderer.domElement)
            if ( arToolkitContext.arController !== null )
            {
                arToolkitSource.copySizeTo(arToolkitContext.arController.canvas)
            }
        }
        arToolkitSource.init(function onReady(){
            onResize()
        });

        // handle resize event
        window.addEventListener('resize', function(){
            onResize()
        });

        ////////////////////////////////////////////////////////////
        // setup arToolkitContext
        ////////////////////////////////////////////////////////////
        // create atToolkitContext
        arToolkitContext = new THREEx.ArToolkitContext({
            cameraParametersUrl: 'data/camera_para.dat',
            detectionMode: 'mono'
        });

        // copy projection matrix to camera when initialization complete
        arToolkitContext.init( function onCompleted(){
            camera.projectionMatrix.copy( arToolkitContext.getProjectionMatrix() );
        });
        ////////////////////////////////////////////////////////////
        // setup markerRoots
        ////////////////////////////////////////////////////////////
        // build markerControls
        markerRootA = new THREE.Group();
        scene.add(markerRootA);
        let markerControls1 = new THREEx.ArMarkerControls(arToolkitContext, markerRootA, {
            type: 'pattern', patternUrl: "data/letterA.patt",
        });

        markerRootB = new THREE.Group();
        scene.add(markerRootB);
        let markerControls2 = new THREEx.ArMarkerControls(arToolkitContext, markerRootB, {
            type: 'pattern', patternUrl: "data/letterB.patt",
        });
        ////////////////////////////////////////////////////////////
        // setup scene
        ////////////////////////////////////////////////////////////

        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;

        let loader = new THREE.TextureLoader();

        sceneGroup = new THREE.Group();
        //markerRootA.add(sceneGroup);

        let floorGeometry = new THREE.PlaneGeometry( 20,20 );
        let floorMaterial = new THREE.ShadowMaterial();
        floorMaterial.opacity = 0.3;
        let floorMesh = new THREE.Mesh( floorGeometry, floorMaterial );
        floorMesh.rotation.x = -Math.PI/2;
        floorMesh.receiveShadow = true;
        sceneGroup.add( floorMesh );

        ballMesh = new THREE.Mesh(
            new THREE.SphereGeometry(0.25, 32, 32),
            new THREE.MeshLambertMaterial({
                map: loader.load("images/basketball-gray.png"),
                color: 0xff8800
            })
        );
        ballMesh.castShadow = true;
        scene.add( ballMesh );

        let light = new THREE.PointLight( 0xffffff, 1, 100 );
        light.position.set( 0,4,0 ); // default; light shining from top
        light.castShadow = true;
        sceneGroup.add( light );

        let lightSphere = new THREE.Mesh(
            new THREE.SphereGeometry(0.1),
            new THREE.MeshBasicMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0.8
            })
        );
        lightSphere.position.copy( light.position );
        sceneGroup.add( lightSphere );

        let ambientLight = new THREE.AmbientLight( 0x666666 );
        sceneGroup.add( ambientLight );
        // let helper = new THREE.CameraHelper( light.shadow.camera );
        // sceneGroup.add( helper );
        //
        // // default normal of a plane is 0,0,1. Apply mesh rotation to it.
        // let clipPlane = new THREE.Plane().setFromNormalAndCoplanarPoint(
        //     new THREE.Vector3(0,1,0), new THREE.Vector3(0,0,0) );
        // renderer.clippingPlanes = [clipPlane];

        scene.add(sceneGroup);
    }
    function update()
    {
        // update artoolkit on every frame
        if ( arToolkitSource.ready !== false )
            arToolkitContext.update( arToolkitSource.domElement );
        if ( markerRootA.visible && markerRootB.visible )
        {
            ballMesh.rotation.z += 0.1;
            markerRootA.getWorldPosition(A);
            markerRootB.getWorldPosition(B);

            ballMesh.position.copy(A);
            dir = B.sub(ballMesh.position);

            let time = (totalTime/1) % 3 - 1;

            //ballMesh.position.copy( A + (dir*time) );

            console.log('A: '+ A.x + ' ' + A.y + ' ' + A.z);
            console.log('Ball: '+ ballMesh.position.x + ' ' + ballMesh.position.y + ' ' + ballMesh.position.z);
            console.log('B: '+ B.x + ' ' + B.y + ' ' + B.z);
            console.log('dir: '+ dir.x + ' ' + dir.y + ' ' + dir.z);
        }
        else if (markerRootA.visible == false && markerRootB.visible == true){

            markerRootB.getWorldPosition(B);
            ballMesh.position.copy(B);
            ballMesh.rotation.z += 0.1;

            sceneGroup.position.copy(B);
            console.log('mkA: '+ markerRootA.visible);
            //console.log('mkB: '+ markerRootB.visible);
            //
            // markerRootA.getWorldPosition(A);
            // markerRootB.getWorldPosition(B);
            //
            // console.log('A: '+ A.x + ' ' + A.y + ' ' + A.z);
            // console.log('B: '+ B.x + ' ' + B.y + ' ' + B.z);
        }
        else if (markerRootA.visible == true && markerRootB.visible == false){

            markerRootA.getWorldPosition(A);
            ballMesh.position.copy(A);
            ballMesh.rotation.z += 0.1;

            //console.log('mkA: '+ markerRootA.visible);
            console.log('mkB: '+ markerRootB.visible);
            //
            // markerRootA.getWorldPosition(A);
            // markerRootB.getWorldPosition(B);
            //
            // console.log('A: '+ A.x + ' ' + A.y + ' ' + A.z);
            // console.log('B: '+ B.x + ' ' + B.y + ' ' + B.z);
        }else{
            ballMesh.position.set(0, 0, 0);
        }

    }

    function render()
    {
        renderer.render( scene, camera );
    }
    function animate()
    {
        requestAnimationFrame(animate);
        deltaTime = clock.getDelta();
        totalTime += deltaTime;
        update();
        render();
    }
</script>
</body>
</html>